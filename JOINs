-- Can you give me all the data in the orders table with the product name attached?

SELECT 
    oi.order_item_id
    , oi.created_at
    , p.product_name
FROM order_items oi
INNER JOIN products p ON oi.product_id = p.product_id
;


--TO TEST IF THIS IS THE PRIMARY KEY. IT SHOULDN`T HAVE DUPLICATES
SELECT
    order_item_id
    , COUNT(*) AS test_if_unique --TO TEST IF THIS IS THE PRIMARY KEY. IT SHOULDN`T HAVE DUPLICATES
FROM order_items
GROUP BY order_item_id
ORDER BY test_if_unique DESC
   
--OR USE THIS INSTEAD BEFORE OR AFTER WRITING YOUR QUERY TO MAKESURE YOU HAVEN`T ADDED DUPLICATES TO YOUR DATA
SELECT COUNT(product_id), COUNT(DISTINCT product_id) FROM products
-- If the results are unique, then there are no duplicates and youre good to go.




--Question #1: 
--If we exclude the discounts that have been given, the expected profit margin for each product is calculated by: (retail price - cost) / retail price. 

--Create a column that flags products with a name that includes “Vintage” as products from Nike Vintage and Nike Official otherwise. 

--(*)Calculate the expected profit margins for each product name and include the group that splits products between Nike Official and Nike Vintage in the result.


SELECT 
    *
FROM products

SELECT
     CASE 
        WHEN product_name LIKE '%Vintage%' THEN 'Nike Vintage'
        Else 'Nike Official'
    END AS other
, product_name
, (retail_price - cost) / retail_price AS profit_margin
FROM products



--Question #2: 
--What is the profit margin for each distribution center? Are there any centers that stand out?

SELECT * FROM distribution_centers

SELECT
    dc.name
    , (SUM(pd.retail_price) - SUM(pd.cost)) / SUM(pd.retail_price) AS profit_margin
FROM products pd
INNER JOIN distribution_centers dc on pd.distribution_center_id = dc.distribution_center_id
GROUP BY dc.name


--Question #3: 
--The real profit margin per order item is calculated by: (sales price - cost) / sales price. By summing up all the order items, we will find the real profit margin generated by the products.

--Calculate the profit margin for the Nike Official products: Nike Pro Tights, Nike Dri-FIT Shorts, and Nike Legend Tee

select * from order_items

SELECT
     pd.product_name 
    , (SUM(oi.sale_price) - SUM(pd.cost)) / SUM(oi.sale_price) AS profit_margin
FROM order_items oi
LEFT JOIN products pd ON oi.product_id = pd.product_id
WHERE 1=1
    AND product_name IN ('Nike Pro Tights', 'Nike Dri-FIT Shorts', 'Nike Legend Tee')
GROUP BY pd.product_name 
;    



--Question #4: 
--Calculate the real profit margin by product and split(case when) the data using the created date before 2021-05-01 and post 2021-05-01 for Nike Official order items.


SELECT * FROM order_items

SELECT products.product_name,
			 CASE WHEN created_at < '2021-05-01' THEN 'Pre-May'
       			ELSE 'Post-May'
       END AS may21_split,
			 (SUM(order_items.sale_price)-SUM(products.cost)) / SUM(order_items.sale_price) AS profit_margin

FROM order_items
		 LEFT JOIN products ON products.product_id = order_items.product_id
          
GROUP BY products.product_name,
				 may21_split
         
ORDER BY products.product_name,
				 may21_split
         
         
--Question #5: 
--Calculate the profit margin by product(we need the product_name) for both Nike Official and Nike Vintage products in a single view(use UNION ALL)

SELECT * FROM order_items
   
   
SELECT
    ps.product_name 
    , (SUM(oi.sale_price) - SUM(ps.cost)) / SUM(oi.sale_price) as profit_margin
FROM order_items oi
LEFT JOIN products ps ON oi.product_id = ps.product_id
GROUP BY ps.product_name
       
UNION ALL
       
SELECT
    ps.product_name 
    , (SUM(ov.sale_price) - SUM(ps.cost)) / SUM(ov.sale_price) As profit_margin
FROM order_items_vintage ov
LEFT JOIN products ps ON ov.product_id = ps.product_id
GROUP BY ps.product_name
       



--Question #6: 
--What are the top 10 products by profit margin from Nike Official and Nike Vintage? Include the product name, profit margin, and what business unit (Nike Official or Nike Vintage) sells the product.

SELECT * FROM products
    
SELECT CASE WHEN product_name LIKE '%Vintage%' THEN 'Nike Vintage'
						ELSE 'Nike Official'
       END AS business_unit,
			 products.product_name,
			 (SUM(order_items.sale_price)-SUM(products.cost)) / SUM(order_items.sale_price) AS profit_margin

FROM order_items
		 LEFT JOIN products ON products.product_id = order_items.product_id
          
GROUP BY products.product_name

UNION ALL

SELECT CASE WHEN product_name LIKE '%Vintage%' THEN 'Nike Vintage'
						ELSE 'Nike Official'
       END AS business_unit,
			 products.product_name,
			 (SUM(order_items_vintage.sale_price)-SUM(products.cost)) / SUM(order_items_vintage.sale_price) AS profit_margin

FROM order_items_vintage
		 LEFT JOIN products ON products.product_id = order_items_vintage.product_id
          
GROUP BY products.product_name

ORDER BY profit_margin DESC

LIMIT 10

     
    
  SELECT 
    --oi.order_item_id
   -- , oi.created_at
     ps.product_name
    , count(oi.order_item_id) as order_count --no need for distinct becaue this is foreign key which is always distinct
FROM order_items as oi
    inner join products as ps on oi.product_id = ps.product_id
where 1=1
    and oi.delivered_at is not NULL
    group by 
    ps.product_name
order by 
    2 desc
    --order_count desc
;


SELECT count(product_id), count(distinct product_id) from products
--a way to makesure youre using the primary key to avoid duplicates. So your results should be equal. 
--Primary keys have only unique values
;


--join order --> prod --> distribution

--As an analyst on the job, when working with tables copy and paste the column name of the first 5 results of the tables
--that way you don`t have to keep doing select * so that way you can visualise what you`re doing
-- if not, you can do the following in the query below;
--We are working with 3 tables in this case. the order_items, products and distribution_centers tables.distribution_centers

select * from order_items limit 10
order_item_id, order_id, created_at
;
select * from products limit 10
category, product_name, distribution_center_id (fk)

select * from distribution_centers limit 10


--Interview Question
--how many unique orders, users, and products are coming from each distribution center?
--tip: when connecting 3 tables, you only need 2 joins
--tip: start by writing select * from, inner join products to orders, then join distribution_centers to products, the come back and specify your select statement details. It`s cleaner and more ordered this way
select 
    dc.name
    , count(oi.order_item_id) as orders_cnt -- no need to use distinct because a primary key never has duplicates
    , count(distinct oi.user_id) as user_dist_cnt --foreign keys do have duplicates sometimes so use distinct
    , count(distinct oi.product_id) as prod_dist_cnt --same as above. This is a foreign key and som use distinct. Also let your aliases cary the distinct(dist) so that anyone or you readin this code later will make the difference
from order_items oi
inner join products ps on oi.product_id = ps.product_id --join products to order_items first
inner join distribution_centers dc on dc.distribution_center_id = ps.distribution_center_id --then join distribution_centers to products second
where 1=1
     and oi.delivered_at is not null
group by
    dc.name
;


select 
employee_name
from employee
where bonus <= 1000
order by employee_name  
    

-- Can you give me all the data in the orders table with the product name attached?

SELECT 
    oi.order_item_id
    , oi.created_at
    , p.product_name
FROM order_items oi
INNER JOIN products p ON oi.product_id = p.product_id
;


--TO TEST IF THIS IS THE PRIMARY KEY. IT SHOULDN`T HAVE DUPLICATES
SELECT
    order_item_id
    , COUNT(*) AS test_if_unique --TO TEST IF THIS IS THE PRIMARY KEY. IT SHOULDN`T HAVE DUPLICATES
FROM order_items
GROUP BY order_item_id
ORDER BY test_if_unique DESC
   
--OR USE THIS INSTEAD BEFORE OR AFTER WRITING YOUR QUERY TO MAKESURE YOU HAVEN`T ADDED DUPLICATES TO YOUR DATA
SELECT COUNT(product_id), COUNT(DISTINCT product_id) FROM products
-- If the results are unique, then there are no duplicates and youre good to go.




